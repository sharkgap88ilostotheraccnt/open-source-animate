<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Mini Animate Fixed</title>
<style>
  body { background: #222; color: #fff; font-family: sans-serif; text-align: center; }
  canvas { background: #333; margin-top: 10px; cursor: move; display:block; margin:auto; }
  button { margin: 5px; padding: 5px 10px; }
  #timeline { width: 600px; height: 60px; background: #444; margin: 10px auto; position: relative; user-select:none; }
  .frame { width: 10px; height: 100%; border-right: 1px solid #555; float: left; }
  .keyframe { width: 8px; height: 8px; background: yellow; position: absolute; top: 25px; cursor: pointer; border-radius: 50%; }
  #playhead { width: 2px; height: 100%; background: red; position: absolute; top: 0; left: 0; cursor: pointer; }
</style>
</head>
<body>
<h2>Mini Animate (Fixed)</h2>
<button id="addObj">‚ûï Rectangle</button>
<button id="createSymbol">üé® New Symbol</button>
<button id="addKey">üé¨ Keyframe</button>
<button id="play">‚ñ∂Ô∏è Play</button>
<canvas id="canvas" width="600" height="400"></canvas>

  <div id="symbolLibrary" style="
  width: 600px; 
  margin: 10px auto; 
  background: #444; 
  color: white; 
  padding: 10px;
  display: flex; 
  flex-wrap: wrap; 
  gap: 10px;
  border-radius: 5px;
  user-select:none;
">
  <strong>Symbol Library:</strong>
</div>

  
<div id="timeline">
  <div id="playhead"></div>
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const timeline = document.getElementById("timeline");
const playhead = document.getElementById("playhead");

let objects = [];
let selected = null;
let dragging = false;
let offsetX, offsetY;
let frames = 60;
let currentFrame = 0;
let keyframes = {};
let isPlaying = false;

const symbolLibraryDiv = document.getElementById("symbolLibrary");
const symbolLibrary = []; // Array to hold symbol images (data URLs)

function updateSymbolLibrary() {
  // Clear current thumbnails except the label
  symbolLibraryDiv.querySelectorAll("img").forEach(img => img.remove());
  
  symbolLibrary.forEach((dataURL, index) => {
    const img = new Image();
    img.src = dataURL;
    img.title = `Symbol ${index + 1}`;
    img.style.width = "60px";
    img.style.height = "60px";
    img.style.objectFit = "contain";
    img.style.cursor = "pointer";
    img.style.border = "2px solid transparent";
    img.onmouseenter = () => img.style.borderColor = "yellow";
    img.onmouseleave = () => img.style.borderColor = "transparent";
    
    img.onclick = () => {
      // Create a new object instance on the stage using this symbol image
      const symbolImg = new Image();
      symbolImg.src = dataURL;
      symbolImg.onload = () => {
        const obj = { 
          id: Date.now(), 
          x: 100, 
          y: 100, 
          w: symbolImg.width / 2, 
          h: symbolImg.height / 2, 
          image: symbolImg, 
          color: null 
        };
        objects.push(obj);
        keyframes[obj.id] = [];
        selected = obj;
        draw();
      };
    };
    symbolLibraryDiv.appendChild(img);
  });
}


  
function initTimeline() {
  timeline.innerHTML = "";
  for (let i = 0; i < frames; i++) {
    const div = document.createElement("div");
    div.className = "frame";
    timeline.appendChild(div);
  }
  timeline.appendChild(playhead);
}
initTimeline();

// Add rectangle
document.getElementById("addObj").onclick = () => {
  const obj = { id: Date.now(), x: 100, y: 100, w: 80, h: 80, color: `hsl(${Math.random()*360},70%,50%)`, image: null };
  objects.push(obj);
  keyframes[obj.id] = [];
  selected = obj;
  draw();
};
document.getElementById("createSymbol").onclick = () => {
  window.open("symbol-editor.html", "SymbolEditor", "width=500,height=500");
};



// Receive symbol from popup
window.receiveSymbol = function(dataURL) {
  const img = new Image();
  img.src = dataURL;
  img.onload = () => {
    const obj = { id: Date.now(), x: 100, y: 100, w: img.width/2, h: img.height/2, image: img, color: null };
    objects.push(obj);
    keyframes[obj.id] = [];
    selected = obj;
    draw();
  };
};

// Dragging objects
canvas.onmousedown = e => {
  const mx = e.offsetX, my = e.offsetY;
  selected = objects.find(o => mx > o.x && mx < o.x+o.w && my > o.y && my < o.y+o.h);
  if (selected) {
    dragging = true;
    offsetX = mx - selected.x;
    offsetY = my - selected.y;
  }
};
canvas.onmousemove = e => { if (dragging && selected) { selected.x = e.offsetX - offsetX; selected.y = e.offsetY - offsetY; draw(); } };
canvas.onmouseup = () => dragging = false;

// Keyframe
document.getElementById("addKey").onclick = () => {
  if (!selected) return;
  let kfs = keyframes[selected.id].filter(k => k.frame !== currentFrame);
  kfs.push({ frame: currentFrame, x: selected.x, y: selected.y });
  keyframes[selected.id] = kfs;
  renderKeyframes();
};

function renderKeyframes() {
  document.querySelectorAll(".keyframe").forEach(e => e.remove());
  for (const id in keyframes) {
    keyframes[id].forEach(kf => {
      const dot = document.createElement("div");
      dot.className = "keyframe";
      dot.style.left = (kf.frame * 10 + 1) + "px";
      dot.onclick = () => { 
        currentFrame = kf.frame; 
        const obj = objects.find(o => o.id == id); 
        obj.x = kf.x; obj.y = kf.y; 
        updatePlayhead(); draw(); 
      };
      timeline.appendChild(dot);
    });
  }
}

// Play animation
document.getElementById("play").onclick = () => {
  if (isPlaying) return;
  isPlaying = true;
  let f = 0;
  (function loop(){
    if (f >= frames) { isPlaying = false; return; }
    currentFrame = f;
    updateObjects(f);
    updatePlayhead();
    draw();
    f++;
    requestAnimationFrame(loop);
  })();
};

function updateObjects(frame) {
  objects.forEach(o => {
    const keys = keyframes[o.id];
    if (!keys || keys.length === 0) return;
    if (keys.length === 1) { o.x = keys[0].x; o.y = keys[0].y; }
    else {
      let prev = keys[0], next = keys[keys.length - 1];
      for (let i = 0; i < keys.length - 1; i++) {
        if (frame >= keys[i].frame && frame <= keys[i+1].frame) { prev = keys[i]; next = keys[i+1]; break; }
      }
      const t = (frame - prev.frame) / (next.frame - prev.frame || 1);
      o.x = prev.x + (next.x - prev.x) * t;
      o.y = prev.y + (next.y - prev.y) * t;
    }
  });
}

function updatePlayhead() { playhead.style.left = (currentFrame * 10) + "px"; }

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  objects.forEach(o => {
    if (o.image) ctx.drawImage(o.image, o.x, o.y, o.w, o.h);
    else { ctx.fillStyle = o.color; ctx.fillRect(o.x, o.y, o.w, o.h); }
    if (o === selected) { ctx.strokeStyle = "#fff"; ctx.strokeRect(o.x-2, o.y-2, o.w+4, o.h+4); }
  });
}
draw();

// Playhead dragging
let draggingPlayhead = false;
playhead.onmousedown = () => draggingPlayhead = true;
document.onmouseup = () => draggingPlayhead = false;
document.onmousemove = e => {
  if (!draggingPlayhead) return;
  const rect = timeline.getBoundingClientRect();
  let x = e.clientX - rect.left;
  x = Math.max(0, Math.min(x, rect.width));
  currentFrame = Math.round(x / 10);
  updatePlayhead();
  updateObjects(currentFrame);
  draw();
};
</script>
</body>
</html>
