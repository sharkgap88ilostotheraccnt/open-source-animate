<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Mini Animate (Graphics Update)</title>
<style>
  body { background: #1c2526; color: #d9d9d9; font-family: 'Helvetica Neue', sans-serif; margin: 0; overflow: hidden; }
  #topToolbar { text-align: center; margin: 10px 0; background: #2e2e2e; padding: 8px; border-bottom: 1px solid #444; }
  button { padding: 8px; cursor: pointer; background: #2e2e2e; color: #d9d9d9; border: 1px solid #444; border-radius: 4px; font-size: 12px; }
  button:hover { background: #4a4a4a; }
  button.active { background: #0078d7; color: #fff; }
  #mainContainer { display: flex; gap: 8px; width: 1000px; margin: 10px auto; background: #252526; padding: 10px; border-radius: 6px; }
  #canvasAndTimeline { flex-grow: 1; position: relative; }
  canvas { background: #333; border: 1px solid #444; display: block; user-select: none; }
  #timeline { width: 100%; height: 80px; background: #2e2e2e; position: relative; border-top: 1px solid #444; margin-top: 8px; border-radius: 4px; }
  .frame { width: 12px; height: 100%; border-right: 1px solid #555; float: left; }
  .frame:nth-child(5n)::before { content: attr(data-frame); position: absolute; top: 5px; font-size: 10px; color: #999; width: 12px; text-align: center; }
  .keyframe { width: 8px; height: 8px; background: #ffd700; position: absolute; top: 30px; cursor: pointer; border-radius: 50%; border: 1px solid #000; }
  #playhead { width: 2px; height: 100%; background: #ff4d4d; position: absolute; top: 0; z-index: 10; }
  #symbolLibrary { width: 180px; background: #2e2e2e; color: #d9d9d9; padding: 10px; display: flex; flex-direction: column; gap: 8px; border-radius: 6px; overflow-y: auto; border: 1px solid #444; }
  #symbolLibrary img { width: 60px; height: 60px; object-fit: contain; cursor: pointer; border: 2px solid transparent; border-radius: 4px; background: #333; }
  #symbolLibrary img:hover { border-color: #ffd700; }
  #transformToolbar { width: 60px; background: #2e2e2e; color: #d9d9d9; padding: 10px; display: flex; flex-direction: column; gap: 8px; border-radius: 6px; border: 1px solid #444; }
  #transformToolbar button { font-size: 14px; padding: 8px; }
</style>
</head>
<body>

<div id="topToolbar">
  <button id="addObj">Add Rectangle</button>
  <button id="addKey">Add Keyframe</button>
  <button id="play">Play</button>
  <button id="createSymbol">New Symbol</button>
  <button id="deleteObj">Delete</button>
</div>

<div id="mainContainer">
  <div id="transformToolbar">
    <strong>Tools</strong>
    <button id="moveTool">↔</button>
    <button id="scaleTool">⬛</button>
    <button id="rotateTool">↻</button>
    <button id="flipH">⇆</button>
    <button id="flipV">⇅</button>
  </div>

  <div id="canvasAndTimeline">
    <canvas id="canvas" width="600" height="400"></canvas>
    <div id="timeline"></div>
  </div>

  <div id="symbolLibrary"><strong>Library</strong></div>
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const timeline = document.getElementById("timeline");
const symbolLibraryDiv = document.getElementById("symbolLibrary");

let objects = [];
let selected = null;
let dragging = false;
let offsetX, offsetY;
let frames = 60, currentFrame = 0;
let keyframes = {};
let isPlaying = false;
let symbolLibrary = [];
let currentTool = "move";

const playhead = document.createElement("div");
playhead.id = "playhead";

function initTimeline() {
  timeline.innerHTML = "";
  for (let i = 0; i < frames; i++) {
    const div = document.createElement("div");
    div.className = "frame";
    div.dataset.frame = i;
    timeline.appendChild(div);
  }
  timeline.appendChild(playhead);
}
initTimeline();

function updatePlayhead() {
  const pos = (currentFrame / (frames - 1)) * timeline.clientWidth;
  playhead.style.left = pos + "px";
}

let scrubDragging = false;
timeline.addEventListener("mousedown", e => { scrubDragging = true; movePlayhead(e); });
timeline.addEventListener("mousemove", e => { if (scrubDragging) movePlayhead(e); });
window.addEventListener("mouseup", () => scrubDragging = false);

function movePlayhead(e) {
  const rect = timeline.getBoundingClientRect();
  const x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
  const frame = Math.floor((x / rect.width) * frames);
  currentFrame = frame;
  updatePlayhead();
  updateObjectsForFrame(frame);
  draw();
}

document.getElementById("addObj").onclick = () => {
  const obj = { id: Date.now(), x: 100, y: 100, w: 80, h: 80, color: `hsl(${Math.random()*360},70%,50%)`, rotation: 0, scaleX: 1, scaleY: 1, image: null };
  objects.push(obj);
  keyframes[obj.id] = [];
  selected = obj;
  draw();
};

document.getElementById("addKey").onclick = () => {
  if (selected) {
    keyframes[selected.id].push({ frame: currentFrame, x: selected.x, y: selected.y, w: selected.w, h: selected.h, rotation: selected.rotation, scaleX: selected.scaleX, scaleY: selected.scaleY });
    renderKeyframes();
  }
};

document.getElementById("play").onclick = () => {
  if (isPlaying) return;
  isPlaying = true;
  let frame = currentFrame;
  function animate() {
    if (frame >= frames) { isPlaying = false; currentFrame = 0; updatePlayhead(); draw(); return; }
    currentFrame = frame;
    updateObjectsForFrame(frame);
    draw();
    updatePlayhead();
    frame++;
    requestAnimationFrame(animate);
  }
  animate();
};

document.getElementById("deleteObj").onclick = () => {
  if (!selected) return;
  objects = objects.filter(o => o !== selected);
  delete keyframes[selected.id];
  selected = null;
  draw(); renderKeyframes();
};

document.getElementById("createSymbol").onclick = () => {
  window.open("editor.html", "SymbolEditor", "width=500,height=500");
};

document.getElementById("moveTool").onclick = () => { currentTool = "move"; };
document.getElementById("scaleTool").onclick = () => { currentTool = "scale"; };
document.getElementById("rotateTool").onclick = () => { currentTool = "rotate"; };
document.getElementById("flipH").onclick = () => { if (selected) { selected.scaleX *= -1; draw(); } };
document.getElementById("flipV").onclick = () => { if (selected) { selected.scaleY *= -1; draw(); } };

function pointInObject(x, y, o) { return x > o.x && x < o.x + o.w && y > o.y && y < o.y + o.h; }

canvas.onmousedown = e => {
  const mx = e.offsetX, my = e.offsetY;
  selected = objects.find(o => pointInObject(mx, my, o));
  if (selected) {
    dragging = true;
    offsetX = mx - selected.x; offsetY = my - selected.y;
  }
};

canvas.onmousemove = e => {
  if (!dragging || !selected) return;
  const mx = e.offsetX, my = e.offsetY;
  selected.x = mx - offsetX;
  selected.y = my - offsetY;
  draw();
};

canvas.onmouseup = () => dragging = false;

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  objects.forEach(o => {
    ctx.save();
    const cx = o.x + o.w/2, cy = o.y + o.h/2;
    ctx.translate(cx, cy);
    ctx.rotate((o.rotation || 0) * Math.PI / 180);
    ctx.scale(o.scaleX || 1, o.scaleY || 1);
    if (o.image) ctx.drawImage(o.image, -o.w/2, -o.h/2, o.w, o.h);
    else { ctx.fillStyle = o.color; ctx.fillRect(-o.w/2, -o.h/2, o.w, o.h); }
    if (o === selected) { ctx.strokeStyle = "#ffd700"; ctx.lineWidth = 2; ctx.strokeRect(-o.w/2, -o.h/2, o.w, o.h); }
    ctx.restore();
  });
}

function renderKeyframes() {
  document.querySelectorAll(".keyframe").forEach(el => el.remove());
  for (const objId in keyframes) {
    keyframes[objId].forEach(kf => {
      const dot = document.createElement("div");
      dot.className = "keyframe";
      dot.style.left = (kf.frame * 12 + 2) + "px";
      dot.onclick = () => {
        currentFrame = kf.frame;
        const obj = objects.find(o => o.id == objId);
        if (obj) {
          Object.assign(obj, kf);
          selected = obj;
          draw(); updatePlayhead();
        }
      };
      timeline.appendChild(dot);
    });
  }
}

function updateObjectsForFrame(frame) {
  objects.forEach(obj => {
    const keys = keyframes[obj.id];
    if (!keys || keys.length < 2) return;
    let prev = keys[0], next = keys[keys.length - 1];
    for (let i = 0; i < keys.length - 1; i++) {
      if (frame >= keys[i].frame && frame <= keys[i+1].frame) { prev = keys[i]; next = keys[i+1]; break; }
    }
    const t = (frame - prev.frame) / (next.frame - prev.frame);
    obj.x = prev.x + (next.x - prev.x) * t;
    obj.y = prev.y + (next.y - prev.y) * t;
    obj.w = prev.w + (next.w - prev.w) * t;
    obj.h = prev.h + (next.h - prev.h) * t;
    obj.rotation = prev.rotation + (next.rotation - prev.rotation) * t;
    obj.scaleX = prev.scaleX + (next.scaleX - prev.scaleX) * t;
    obj.scaleY = prev.scaleY + (next.scaleY - prev.scaleY) * t;
  });
}

window.receiveSymbol = function(dataURL) {
  symbolLibrary.push(dataURL);
  updateSymbolLibrary();
  const img = new Image(); img.src = dataURL;
  img.onload = () => {
    const obj = { id: Date.now(), x: 100, y: 100, w: img.width/2, h: img.height/2, rotation: 0, scaleX: 1, scaleY: 1, image: img };
    objects.push(obj); keyframes[obj.id] = []; selected = obj; draw();
  };
};

function updateSymbolLibrary() {
  symbolLibraryDiv.querySelectorAll("img").forEach(img => img.remove());
  symbolLibrary.forEach((dataURL, i) => {
    const img = new Image(); img.src = dataURL; img.title = `Symbol ${i+1}`;
    img.onclick = () => {
      const symbolImg = new Image(); symbolImg.src = dataURL;
      symbolImg.onload = () => {
        const obj = { id: Date.now(), x: 100, y: 100, w: symbolImg.width/2, h: symbolImg.height/2, rotation: 0, scaleX: 1, scaleY: 1, image: symbolImg };
        objects.push(obj); keyframes[obj.id] = []; selected = obj; draw();
      };
    };
    symbolLibraryDiv.appendChild(img);
  });
}

draw();
</script>
</body>
</html>
