<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Mini Animate - Editor</title>
<style>
  body {
    background: #1c2526;
    color: #d9d9d9;
    font-family: 'Helvetica Neue', Arial, sans-serif;
    margin: 0; padding: 10px;
  }
  #topToolbar {
    text-align: center;
    margin-bottom: 10px;
  }
  button {
    padding: 8px 15px;
    margin: 0 5px;
    background: #2e2e2e;
    color: #d9d9d9;
    border: 1px solid #444;
    border-radius: 4px;
    cursor: pointer;
  }
  button:hover {
    background: #444;
  }
  canvas {
    background: #333;
    display: block;
    margin: 0 auto;
    border: 1px solid #444;
  }
  #timeline {
    width: 600px;
    height: 60px;
    background: #2e2e2e;
    margin: 10px auto;
    position: relative;
    user-select: none;
    border-radius: 4px;
  }
  .frame {
    width: 10px;
    height: 100%;
    border-right: 1px solid #555;
    float: left;
    position: relative;
  }
  .keyframe {
    width: 8px;
    height: 8px;
    background: #ffd700;
    position: absolute;
    top: 25px;
    cursor: pointer;
    border-radius: 50%;
    border: 1px solid #000;
  }
  #playhead {
    width: 2px;
    height: 100%;
    background: #ff4d4d;
    position: absolute;
    top: 0;
    z-index: 10;
  }
</style>
</head>
<body>

<div id="topToolbar">
  <button id="addObj">Add Rectangle</button>
  <button id="addKey">Add Keyframe</button>
  <button id="play">Play</button>
  <button id="saveProject">üíæ Save Project (JSON)</button>
  <button id="exportPNG">üñºÔ∏è Export Current Frame PNG</button>
</div>

<canvas id="canvas" width="600" height="400"></canvas>
<div id="timeline"></div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const timeline = document.getElementById("timeline");

let objects = [];
let keyframes = {};
let frames = 60;
let currentFrame = 0;
let selected = null;
let isPlaying = false;

// Playhead div
const playhead = document.createElement("div");
playhead.id = "playhead";
timeline.appendChild(playhead);

// Initialize timeline frames
function initTimeline() {
  timeline.innerHTML = "";
  for (let i = 0; i < frames; i++) {
    const frameDiv = document.createElement("div");
    frameDiv.className = "frame";
    frameDiv.dataset.frame = i;
    timeline.appendChild(frameDiv);
  }
  timeline.appendChild(playhead);
}
initTimeline();

function updatePlayhead() {
  const pos = (currentFrame / (frames - 1)) * timeline.clientWidth;
  playhead.style.left = pos + "px";
}

// Timeline click to scrub frames
timeline.addEventListener("click", e => {
  const rect = timeline.getBoundingClientRect();
  let x = e.clientX - rect.left;
  if (x < 0) x = 0;
  if (x > rect.width) x = rect.width;
  currentFrame = Math.floor((x / rect.width) * frames);
  updatePlayhead();
  updateObjectsForFrame(currentFrame);
  draw();
});

// Add object button
document.getElementById("addObj").onclick = () => {
  const obj = {
    id: Date.now(),
    x: 100,
    y: 100,
    w: 80,
    h: 80,
    color: `hsl(${Math.random() * 360}, 70%, 50%)`,
  };
  objects.push(obj);
  keyframes[obj.id] = [];
  selected = obj;
  draw();
};

// Add keyframe button
document.getElementById("addKey").onclick = () => {
  if (!selected) return alert("Select an object first!");
  keyframes[selected.id].push({
    frame: currentFrame,
    x: selected.x,
    y: selected.y,
    w: selected.w,
    h: selected.h,
  });
  renderKeyframes();
};

// Render keyframes on timeline
function renderKeyframes() {
  document.querySelectorAll(".keyframe").forEach(kf => kf.remove());
  for (const objId in keyframes) {
    keyframes[objId].forEach(kf => {
      const dot = document.createElement("div");
      dot.className = "keyframe";
      dot.style.left = (kf.frame * 10) + "px";
      dot.onclick = () => {
        currentFrame = kf.frame;
        const obj = objects.find(o => o.id == objId);
        if (obj) {
          obj.x = kf.x;
          obj.y = kf.y;
          obj.w = kf.w;
          obj.h = kf.h;
          selected = obj;
          draw();
          updatePlayhead();
        }
      };
      timeline.appendChild(dot);
    });
  }
}

// Update object positions between keyframes (linear tween)
function updateObjectsForFrame(frame) {
  objects.forEach(obj => {
    const kfs = keyframes[obj.id];
    if (!kfs || kfs.length < 2) return;
    let prev = kfs[0], next = kfs[kfs.length - 1];
    for (let i = 0; i < kfs.length - 1; i++) {
      if (frame >= kfs[i].frame && frame <= kfs[i + 1].frame) {
        prev = kfs[i];
        next = kfs[i + 1];
        break;
      }
    }
    const t = (frame - prev.frame) / (next.frame - prev.frame);
    obj.x = prev.x + (next.x - prev.x) * t;
    obj.y = prev.y + (next.y - prev.y) * t;
    obj.w = prev.w + (next.w - prev.w) * t;
    obj.h = prev.h + (next.h - prev.h) * t;
  });
}

// Draw function
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  objects.forEach(obj => {
    ctx.fillStyle = obj.color;
    ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
    if (obj === selected) {
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.strokeRect(obj.x - 2, obj.y - 2, obj.w + 4, obj.h + 4);
    }
  });
}

// Select object on canvas click
canvas.addEventListener("mousedown", e => {
  const mx = e.offsetX, my = e.offsetY;
  selected = objects.find(o => mx > o.x && mx < o.x + o.w && my > o.y && my < o.y + o.h);
  draw();
});

// Play animation
document.getElementById("play").onclick = () => {
  if (isPlaying) return;
  isPlaying = true;
  let frame = currentFrame;
  function animate() {
    if (frame >= frames) {
      isPlaying = false;
      currentFrame = 0;
      updatePlayhead();
      draw();
      return;
    }
    currentFrame = frame;
    updateObjectsForFrame(frame);
    draw();
    updatePlayhead();
    frame++;
    requestAnimationFrame(animate);
  }
  animate();
};

// Save project JSON
document.getElementById("saveProject").onclick = () => {
  const data = {
    objects,
    keyframes,
    frames,
    currentFrame,
  };
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "mini_animate_project.json";
  a.click();
};

// Export PNG of current frame
document.getElementById("exportPNG").onclick = () => {
  const link = document.createElement("a");
  link.download = `frame_${currentFrame}.png`;
  link.href = canvas.toDataURL("image/png");
  link.click();
};

// Load project if loaded from main menu
const loaded = localStorage.getItem("loadedProject");
if (loaded) {
  const data = JSON.parse(loaded);
  objects = data.objects || [];
  keyframes = data.keyframes || {};
  frames = data.frames || 60;
  currentFrame = data.currentFrame || 0;
  localStorage.removeItem("loadedProject");
  initTimeline();
  renderKeyframes();
  updatePlayhead();
  draw();
}

</script>

</body>
</html>
