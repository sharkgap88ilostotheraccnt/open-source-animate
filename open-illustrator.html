<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Open Illustrator V3.0 - Adobe Style Vector Toolbar</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap');
  * {
    box-sizing: border-box;
  }
  html, body {
    margin:0; padding:0;
    height: 100%;
    background: #1e1e1e;
    color: #ddd;
    font-family: 'Inter', sans-serif;
    user-select: none;
    overflow: hidden;
    font-size: 13px;
  }
  #app {
    display: flex;
    flex-direction: column;
    height: 100vh;
    width: 100vw;
  }

  /* Top bar */
  #topbar {
    height: 44px;
    background: #2a2a2a;
    border-bottom: 1px solid #444;
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 0 16px;
    font-weight: 600;
  }
  #topbar button {
    background: #333;
    border: 1px solid #444;
    color: #ccc;
    padding: 6px 14px;
    border-radius: 3px;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 13px;
  }
  #topbar button:hover, #topbar button.selected {
    background: #f57c00;
    border-color: #f57c00;
    color: #222;
  }

  /* Main layout */
#main {
  display: flex;
  flex: 1;
  height: 100%;
  min-height: 0; /* allows flex children to shrink properly */
}


  /* Toolbar left side */
#toolbar {
  width: 160px; /* fixed width */
  display: flex;
  flex-direction: column;
  border-right: 2px solid #444;
  background: #2b2b2b;
}

  .tool-button {
    width: 56px;
    height: 56px;
    margin: 8px 0;
    background: transparent;
    border: none;
    cursor: pointer;
    outline: none;
    display: flex;
    flex-direction: column;
    align-items: center;
    color: #aaa;
    transition: color 0.3s ease, background-color 0.3s ease;
    user-select: none;
  }
  .tool-button svg {
    width: 28px;
    height: 28px;
    fill: none;
    stroke: #aaa;
    stroke-width: 2;
    stroke-linejoin: round;
    stroke-linecap: round;
    transition: stroke 0.3s ease;
  }
  .tool-button span {
    font-size: 10px;
    margin-top: 4px;
    color: #aaa;
    user-select: none;
  }
  .tool-button:hover, .tool-button.selected {
    color: #f57c00;
  }
  .tool-button:hover svg, .tool-button.selected svg {
    stroke: #f57c00;
  }

  /* Settings bar below toolbar */
  #settings-bar {
    margin-top: auto;
    width: 100%;
    padding: 12px 8px;
    background: #363636;
    border-top: 1px solid #444;
    color: #ddd;
    font-size: 11px;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  #settings-bar label {
    font-weight: 600;
    margin-bottom: 4px;
    user-select: none;
  }
  #settings-bar input[type=color],
  #settings-bar input[type=number] {
    width: 100%;
    padding: 4px 6px;
    border-radius: 3px;
    border: 1px solid #555;
    background: #222;
    color: #eee;
    font-size: 12px;
  }

  /* Canvas container and canvas */
#canvas-container {
  flex: 1; /* this makes it expand to fill available space */
  min-width: 0; /* important for flexbox overflow control */
  min-height: 0; /* same for vertical */
  display: flex;
  justify-content: center;
  align-items: center;
  background: #1c1c1c;
}


canvas {
  max-width: 100%;
  max-height: 100%;
  width: auto;  /* allows width to scale */
  height: auto; /* allows height to scale */
  background: white;
  border: 1px solid #666;
  display: block;
}



  /* Status bar */
  #statusbar {
    height: 24px;
    background: #222;
    border-top: 1px solid #444;
    color: #ddd;
    font-size: 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 16px;
    user-select: none;
  }
</style>
</head>
<body>
  <div id="app">
    <div id="topbar" role="toolbar" aria-label="Main Toolbar">
      <button id="undoBtn" title="Undo (Ctrl+Z)">Undo</button>
      <button id="redoBtn" title="Redo (Ctrl+Y)">Redo</button>
      <button id="exportPNGBtn" title="Export as PNG">Export PNG</button>
      <button id="saveJSONBtn" title="Save as .oi">Save .oi</button>
    </div>
    <div id="main">
      <nav id="toolbar" role="toolbar" aria-label="Tools">
        <!-- Tool buttons with inline SVG icons and text -->
        <button class="tool-button selected" data-tool="select" title="Select Tool" aria-pressed="true" tabindex="0">
          <svg viewBox="0 0 24 24"><path d="M3 3l18 9-9 9z"/></svg>
          <span>Select</span>
        </button>
        <button class="tool-button" data-tool="rect" title="Rectangle Tool" tabindex="-1">
          <svg viewBox="0 0 24 24"><rect x="4" y="4" width="16" height="16" rx="2" ry="2"/></svg>
          <span>Rect</span>
        </button>
        <button class="tool-button" data-tool="ellipse" title="Ellipse Tool" tabindex="-1">
          <svg viewBox="0 0 24 24"><ellipse cx="12" cy="12" rx="9" ry="6"/></svg>
          <span>Ellipse</span>
        </button>
        <button class="tool-button" data-tool="line" title="Line Tool" tabindex="-1">
          <svg viewBox="0 0 24 24"><line x1="4" y1="20" x2="20" y2="4"/></svg>
          <span>Line</span>
        </button>
        <button class="tool-button" data-tool="pen" title="Pen Tool" tabindex="-1">
          <svg viewBox="0 0 24 24"><path d="M3 21l18-18M14 7l3 3-7 7-3-3 7-7z"/></svg>
          <span>Pen</span>
        </button>
        <button class="tool-button" data-tool="eraser" title="Eraser Tool" tabindex="-1">
          <svg viewBox="0 0 24 24"><path d="M18 6l-6 6-6-6-2 2 8 8 8-8-2-2z"/></svg>
          <span>Eraser</span>
        </button>
        <button class="tool-button" data-tool="polygon" title="Polygon Tool" tabindex="-1">
          <svg viewBox="0 0 24 24"><polygon points="12 2 19 7 16 19 8 19 5 7"/></svg>
          <span>Polygon</span>
        </button>
        <button class="tool-button" data-tool="bezier" title="Bezier Tool" tabindex="-1">
          <svg viewBox="0 0 24 24"><path d="M4 19c7-12 7 0 16-12"/></svg>
          <span>Bezier</span>
        </button>
        <button class="tool-button" data-tool="text" title="Text Tool" tabindex="-1">
          <svg viewBox="0 0 24 24"><text x="6" y="18" font-family="Arial" font-size="14" fill="none" stroke="#aaa" stroke-width="1">T</text></svg>
          <span>Text</span>
        </button>
      </nav>
      <aside id="settings-bar" aria-label="Tool Settings">
        <label for="fillColorPicker">Fill Color</label>
        <input type="color" id="fillColorPicker" value="#000000" aria-label="Fill Color Picker" />
        <label for="strokeColorPicker">Stroke Color</label>
        <input type="color" id="strokeColorPicker" value="#000000" aria-label="Stroke Color Picker" />
        <label for="strokeWidthInput">Stroke Width</label>
        <input type="number" id="strokeWidthInput" value="2" min="1" max="20" aria-label="Stroke Width Input" />
        <label for="polygonSidesInput">Polygon Sides</label>
        <input type="number" id="polygonSidesInput" value="5" min="3" max="12" aria-label="Polygon Sides Input" />
      </aside>
      <section id="canvas-container">
        <canvas id="canvas" tabindex="0" aria-label="Drawing Canvas"></canvas>
      </section>
    </div>
    <div id="statusbar" role="status" aria-live="polite">
      <div id="currentTool">Tool: Select</div>
      <div id="coords">X: 0 Y: 0</div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const container = document.getElementById("canvas-container");
  const fillColorPicker = document.getElementById("fillColorPicker");
  const strokeColorPicker = document.getElementById("strokeColorPicker");
  const strokeWidthInput = document.getElementById("strokeWidthInput");
  const polygonSidesInput = document.getElementById("polygonSidesInput");
  const currentToolEl = document.getElementById("currentTool");
  const coordsEl = document.getElementById("coords");
  const toolbar = document.getElementById("toolbar");

  let w, h;
  let shapes = [];
  let history = [];
  let historyIndex = -1;

  let tool = "select";
  let isDrawing = false;
  let startX = 0, startY = 0;
  let currentShape = null;
  let selectedShape = null;
  let resizing = false;
  let activeHandle = null;

  let bezierPoints = [];

function resize() {
  const rect = container.getBoundingClientRect();
  canvas.width = rect.width * 0.95;
  canvas.height = rect.height * 0.95;
  // Do NOT set canvas.style.width/height here to avoid conflicts with CSS flexbox sizing
  redraw();
}

  window.addEventListener("resize", resize);

  function getCanvasCoords(e) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    let x = (e.clientX - rect.left) * scaleX;
    let y = (e.clientY - rect.top) * scaleY;
    x = Math.min(Math.max(0, x), canvas.width);
    y = Math.min(Math.max(0, y), canvas.height);
    return { x, y };
  }

  function saveState() {
    history = history.slice(0, historyIndex + 1);
    history.push(JSON.stringify(shapes));
    historyIndex++;
  }
  function undo() {
    if (historyIndex > 0) {
      historyIndex--;
      shapes = JSON.parse(history[historyIndex]);
      selectedShape = null;
      redraw();
    }
  }
  function redo() {
    if (historyIndex < history.length - 1) {
      historyIndex++;
      shapes = JSON.parse(history[historyIndex]);
      selectedShape = null;
      redraw();
    }
  }

  function setTool(name) {
    tool = name;
    [...toolbar.querySelectorAll(".tool-button")].forEach(b => {
      const isActive = b.dataset.tool === name;
      b.classList.toggle("selected", isActive);
      b.setAttribute("aria-pressed", isActive ? "true" : "false");
      b.tabIndex = isActive ? 0 : -1;
    });
    selectedShape = null;
    bezierPoints = [];
    currentToolEl.textContent = "Tool: " + name.charAt(0).toUpperCase() + name.slice(1);
    redraw();
  }
  toolbar.addEventListener("click", e => {
    const btn = e.target.closest(".tool-button");
    if (!btn) return;
    const newTool = btn.dataset.tool;
    if (newTool) setTool(newTool);
  });
  setTool("select");

  function redraw() {
    ctx.clearRect(0, 0, w, h);
    shapes.forEach(s => {
      ctx.fillStyle = s.fill || 'transparent';
      ctx.strokeStyle = s.color || '#000';
      ctx.lineWidth = s.width || 1;
      ctx.beginPath();

      if (s.type === "rect") {
        const x = Math.min(s.x1, s.x2), y = Math.min(s.y1, s.y2);
        const width = Math.abs(s.x2 - s.x1);
        const height = Math.abs(s.y2 - s.y1);
        if (s.fill) ctx.fillRect(x, y, width, height);
        ctx.strokeRect(x, y, width, height);
      } else if (s.type === "ellipse") {
        const rx = Math.abs((s.x2 - s.x1) / 2), ry = Math.abs((s.y2 - s.y1) / 2);
        const cx = Math.min(s.x1, s.x2) + rx;
        const cy = Math.min(s.y1, s.y2) + ry;
        ctx.ellipse(cx, cy, rx, ry, 0, 0, 2 * Math.PI);
        if (s.fill) ctx.fill();
        ctx.stroke();
      } else if (s.type === "line") {
        ctx.moveTo(s.x1, s.y1);
        ctx.lineTo(s.x2, s.y2);
        ctx.stroke();
      } else if (s.type === "pen") {
        if (s.points.length > 0) {
          ctx.moveTo(s.points[0].x, s.points[0].y);
          s.points.slice(1).forEach(p => ctx.lineTo(p.x, p.y));
          ctx.stroke();
          if (selectedShape === s) {
            ctx.fillStyle = "#ffd700";
            s.points.forEach(p => ctx.fillRect(p.x - 3, p.y - 3, 6, 6));
          }
        }
      } else if (s.type === "polygon") {
        drawPolygon(ctx, s.x1, s.y1, s.radius, s.sides);
        if (s.fill) ctx.fill();
        ctx.stroke();
      } else if (s.type === "bezier") {
        if (s.points.length === 4) {
          const [p0, p1, p2, p3] = s.points;
          ctx.moveTo(p0.x, p0.y);
          ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
          ctx.stroke();
          if (selectedShape === s) {
            ctx.fillStyle = "#ffd700";
            s.points.forEach(p => ctx.fillRect(p.x - 4, p.y - 4, 8, 8));
          }
        }
      } else if (s.type === "text") {
        ctx.fillStyle = s.color || "#000";
        ctx.font = `${s.fontSize || 20}px sans-serif`;
        ctx.fillText(s.text, s.x, s.y);
      }

      if (selectedShape === s) drawHandles(s);
    });
  }

  function drawPolygon(ctx, cx, cy, radius, sides) {
    if (sides < 3) return;
    const angle = (Math.PI * 2) / sides;
    ctx.beginPath();
    ctx.moveTo(cx + radius * Math.cos(0), cy + radius * Math.sin(0));
    for (let i = 1; i < sides; i++) {
      ctx.lineTo(cx + radius * Math.cos(i * angle), cy + radius * Math.sin(i * angle));
    }
    ctx.closePath();
  }

  function drawHandles(s) {
    removeHandles();
    let handles = [];

    if (s.type === "rect" || s.type === "ellipse") {
      const minX = Math.min(s.x1, s.x2);
      const maxX = Math.max(s.x1, s.x2);
      const minY = Math.min(s.y1, s.y2);
      const maxY = Math.max(s.y1, s.y2);
      handles = [
        { name: "tl", x: minX, y: minY },
        { name: "tr", x: maxX, y: minY },
        { name: "bl", x: minX, y: maxY },
        { name: "br", x: maxX, y: maxY }
      ];
    } else if (s.type === "polygon") {
      const angleStep = (Math.PI * 2) / s.sides;
      for (let i = 0; i < s.sides; i++) {
        handles.push({
          name: "v" + i,
          x: s.x1 + s.radius * Math.cos(i * angleStep),
          y: s.y1 + s.radius * Math.sin(i * angleStep),
        });
      }
    } else if (s.type === "bezier") {
      handles = s.points.map((p, i) => ({ name: "p" + i, x: p.x, y: p.y }));
    }

    handles.forEach(h => {
      const div = document.createElement("div");
      div.classList.add("handle");
      div.style.position = "absolute";
      div.style.width = "10px";
      div.style.height = "10px";
      div.style.background = "#f57c00";
      div.style.border = "2px solid #fff";
      div.style.borderRadius = "50%";
      div.style.cursor = "pointer";
      div.style.left = (h.x / canvas.width) * canvas.clientWidth - 5 + "px";
      div.style.top = (h.y / canvas.height) * canvas.clientHeight - 5 + "px";
      div.dataset.handle = h.name;
      div.dataset.shapeId = shapes.indexOf(selectedShape);
      document.getElementById("canvas-container").appendChild(div);

      div.addEventListener("mousedown", e => {
        e.stopPropagation();
        resizing = true;
        activeHandle = { shape: selectedShape, handle: h.name };
      });
    });
  }
  function removeHandles() {
    document.querySelectorAll("#canvas-container .handle").forEach(h => h.remove());
  }

  canvas.addEventListener("mousedown", e => {
    const pos = getCanvasCoords(e);

    if (tool === "select") {
      selectedShape = findShapeAt(pos.x, pos.y);
      if (!selectedShape) {
        selectedShape = null;
      }
      redraw();
      return;
    }

    isDrawing = true;
    startX = pos.x;
    startY = pos.y;

    if (tool === "pen") {
      if (!currentShape || currentShape.type !== "pen") {
        currentShape = { type: "pen", points: [{ x: startX, y: startY }], color: strokeColorPicker.value, width: +strokeWidthInput.value };
        shapes.push(currentShape);
      } else {
        currentShape.points.push({ x: startX, y: startY });
      }
      saveState();
      redraw();
      return;
    }

    if (tool === "bezier") {
      bezierPoints.push({ x: startX, y: startY });
      if (bezierPoints.length === 4) {
        shapes.push({ type: "bezier", points: [...bezierPoints], color: strokeColorPicker.value, width: +strokeWidthInput.value });
        bezierPoints = [];
        saveState();
        redraw();
      }
      return;
    }

    if (tool === "text") {
      const text = prompt("Enter text:");
      if (text) {
        shapes.push({ type: "text", x: startX, y: startY, text, color: strokeColorPicker.value, fontSize: 24 });
        saveState();
        redraw();
      }
      isDrawing = false;
      return;
    }

    currentShape = { type: tool, x1: startX, y1: startY, x2: startX, y2: startY, fill: fillColorPicker.value, color: strokeColorPicker.value, width: +strokeWidthInput.value };
    if (tool === "polygon") {
      currentShape.sides = +polygonSidesInput.value || 5;
      currentShape.radius = 0;
    }
    shapes.push(currentShape);
    saveState();
  });

  canvas.addEventListener("mousemove", e => {
    const pos = getCanvasCoords(e);
    coordsEl.textContent = `X: ${pos.x.toFixed(0)} Y: ${pos.y.toFixed(0)}`;

    if (!isDrawing) return;

    if (resizing && activeHandle) {
      const s = activeHandle.shape;
      const h = activeHandle.handle;
      // Handle resize logic here (simplified)
      if (s.type === "rect" || s.type === "ellipse") {
        switch(h) {
          case "tl": s.x1 = pos.x; s.y1 = pos.y; break;
          case "tr": s.x2 = pos.x; s.y1 = pos.y; break;
          case "bl": s.x1 = pos.x; s.y2 = pos.y; break;
          case "br": s.x2 = pos.x; s.y2 = pos.y; break;
        }
      } else if (s.type === "polygon") {
        // Adjust radius or positions
        const dx = pos.x - s.x1;
        const dy = pos.y - s.y1;
        s.radius = Math.sqrt(dx*dx + dy*dy);
      } else if (s.type === "bezier") {
        const idx = parseInt(h.slice(1));
        s.points[idx].x = pos.x;
        s.points[idx].y = pos.y;
      }
      redraw();
      return;
    }

    if (!currentShape) return;
    if (tool === "rect" || tool === "ellipse" || tool === "line") {
      currentShape.x2 = pos.x;
      currentShape.y2 = pos.y;
    } else if (tool === "polygon") {
      currentShape.radius = Math.sqrt((pos.x - currentShape.x1) ** 2 + (pos.y - currentShape.y1) ** 2);
    }
    redraw();
  });

  window.addEventListener("mouseup", e => {
    if (isDrawing) {
      isDrawing = false;
      currentShape = null;
      saveState();
    }
    if (resizing) {
      resizing = false;
      activeHandle = null;
      saveState();
    }
  });

  function findShapeAt(x, y) {
    for (let i = shapes.length - 1; i >= 0; i--) {
      const s = shapes[i];
      if (s.type === "rect") {
        const minX = Math.min(s.x1, s.x2);
        const maxX = Math.max(s.x1, s.x2);
        const minY = Math.min(s.y1, s.y2);
        const maxY = Math.max(s.y1, s.y2);
        if (x >= minX && x <= maxX && y >= minY && y <= maxY) return s;
      } else if (s.type === "ellipse") {
        const rx = Math.abs((s.x2 - s.x1) / 2);
        const ry = Math.abs((s.y2 - s.y1) / 2);
        const cx = Math.min(s.x1, s.x2) + rx;
        const cy = Math.min(s.y1, s.y2) + ry;
        // Point ellipse test
        if (((x - cx) ** 2) / (rx * rx) + ((y - cy) ** 2) / (ry * ry) <= 1) return s;
      } else if (s.type === "line") {
        // line hit test - allow small tolerance
        const d1 = distance(x, y, s.x1, s.y1);
        const d2 = distance(x, y, s.x2, s.y2);
        const lineLen = distance(s.x1, s.y1, s.x2, s.y2);
        if (Math.abs(d1 + d2 - lineLen) < 5) return s;
      } else if (s.type === "polygon") {
        if (pointInPolygon(x, y, s)) return s;
      } else if (s.type === "bezier") {
        // TODO: Bezier hit test - skipping for now
      } else if (s.type === "pen") {
        for (const p of s.points) {
          if (distance(x, y, p.x, p.y) < 6) return s;
        }
      } else if (s.type === "text") {
        // simple bounding box for text
        ctx.font = `${s.fontSize || 20}px sans-serif`;
        const width = ctx.measureText(s.text).width;
        const height = s.fontSize || 20;
        if (x >= s.x && x <= s.x + width && y >= s.y - height && y <= s.y) return s;
      }
    }
    return null;
  }
  function distance(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
  }
  function pointInPolygon(x, y, poly) {
    let inside = false;
    const sides = poly.sides;
    const angleStep = (Math.PI * 2) / sides;
    const cx = poly.x1;
    const cy = poly.y1;
    const r = poly.radius;
    let vertices = [];
    for (let i = 0; i < sides; i++) {
      vertices.push({
        x: cx + r * Math.cos(i * angleStep),
        y: cy + r * Math.sin(i * angleStep),
      });
    }
    for (let i = 0, j = sides - 1; i < sides; j = i++) {
      if (
        (vertices[i].y > y) !== (vertices[j].y > y) &&
        x < ((vertices[j].x - vertices[i].x) * (y - vertices[i].y)) / (vertices[j].y - vertices[i].y) + vertices[i].x
      ) {
        inside = !inside;
      }
    }
    return inside;
  }

  // Undo/Redo buttons
  document.getElementById("undoBtn").onclick = undo;
  document.getElementById("redoBtn").onclick = redo;

  // Save .oi file (fake JSON)
  document.getElementById("saveJSONBtn").onclick = () => {
    const dataStr = JSON.stringify(shapes, null, 2);
    const blob = new Blob([dataStr], { type: "application/json" });
    const a = document.createElement("a");
    a.download = "drawing.oi";
    a.href = URL.createObjectURL(blob);
    a.click();
    URL.revokeObjectURL(a.href);
  };

  // Export PNG
  document.getElementById("exportPNGBtn").onclick = () => {
    const dataUrl = canvas.toDataURL("image/png");
    const a = document.createElement("a");
    a.download = "drawing.png";
    a.href = dataUrl;
    a.click();
  };

  // Initialize canvas size
  resize();
  saveState();
})();
</script>
</body>
</html>
