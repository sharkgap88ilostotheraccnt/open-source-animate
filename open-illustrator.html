<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Open Illustrator V2.0 - Toolbox with settings bar</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet" />
<style>
  /* ... (all your existing styles, unchanged) ... */
  * {
    box-sizing: border-box;
  }
  html, body {
    height: 100%;
    margin: 0; padding: 0;
    background: #1c1c1c;
    color: #e0e0e0;
    font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select: none;
    overflow: hidden;
    font-size: 12px;
  }

  body, #app {
    display: flex;
    flex-direction: column;
    height: 100vh;
    width: 100vw;
  }

  #topbar {
    height: 48px;
    background: #2a2a2a;
    border-bottom: 1px solid #444;
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 0 12px;
  }
  #topbar button {
    height: 28px;
    border: 1px solid #555;
    background: #1e1e1e;
    color: white;
    border-radius: 4px;
    padding: 0 12px;
    cursor: pointer;
    font-size: 12px;
    user-select: none;
  }
  #topbar button:hover {
    background: #f57c00;
    border-color: #f57c00;
  }

  #main {
    flex: 1;
    display: flex;
    background: #1c1c1c;
  }

  #toolbox-container {
    display: flex;
    flex-direction: column;
    width: 160px;
    border-right: 2px solid #444;
    background: #2b2b2b;
  }

  #toolbox {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    padding: 12px;
    box-sizing: border-box;
    background: #333;
    border-bottom: 2px solid #444;
    user-select: none;
  }
  .tool-btn {
    background: #444;
    border: 2px solid transparent;
    cursor: pointer;
    border-radius: 8px;
    color: #ddd;
    font-size: 32px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    user-select: none;
    transition: background 0.3s, border-color 0.3s, color 0.3s;
    height: 80px;
    padding: 6px 0;
  }
  .tool-btn small {
    font-size: 11px;
    margin-top: 4px;
    color: #bbb;
  }
  .tool-btn:hover {
    background: #555;
    border-color: #f57c00;
    color: #f57c00;
  }
  .tool-btn.selected {
    background: #f57c00;
    color: #222;
    border-color: #f57c00;
    font-weight: 700;
  }

  #settings-bar {
    padding: 10px 12px;
    display: flex;
    gap: 12px;
    background: #333;
    border-top: 2px solid #444;
    user-select: none;
  }
  #settings-bar > div {
    display: flex;
    flex-direction: column;
    gap: 4px;
    flex: 1;
    font-size: 12px;
  }
  #settings-bar label {
    font-size: 11px;
    color: #ccc;
  }
  #settings-bar input[type=color],
  #settings-bar input[type=number] {
    border-radius: 4px;
    border: 1px solid #555;
    background: #1e1e1e;
    color: white;
    height: 28px;
    padding: 0 8px;
    font-size: 12px;
  }
  #settings-bar input[type=number] {
    width: 100%;
  }

  #canvas-container {
    flex: 1;
    background: #2d2d2d;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
  }
  canvas {
    background: white;
    border: 1px solid #ccc;
    width: 90%;
    height: 90%;
    cursor: crosshair;
    user-select: none;
  }

  .handle {
    width: 12px;
    height: 12px;
    background: #fdd835;
    border: 2px solid #000;
    position: absolute;
    transform: translate(-50%, -50%);
    cursor: pointer;
    border-radius: 50%;
    box-shadow: 0 0 4px rgba(0,0,0,0.6);
    pointer-events: auto;
    z-index: 10;
  }

  #statusbar {
    height: 24px;
    background: #222;
    border-top: 1px solid #444;
    color: #eee;
    font-size: 12px;
    padding: 4px 12px;
    display: flex;
    justify-content: space-between;
    user-select: none;
  }
</style>
</head>
<body>
  <div id="app">
    <div id="topbar" role="toolbar" aria-label="Main Toolbar">
      <button id="undoBtn" title="Undo (Ctrl+Z)">Undo</button>
      <button id="redoBtn" title="Redo (Ctrl+Y)">Redo</button>
      <button id="exportPNGBtn" title="Export as PNG">Export PNG</button>
      <button id="saveOI" title="Save as .oi (JSON)">Save .oi</button>
      <button id="loadOI" title="Load .oi file">Load .oi</button>
      <input type="file" id="fileInput" style="display:none" accept=".oi,.json" />
    </div>
    <div id="main">
      <div id="toolbox-container" aria-label="Toolbox and settings">
        <div id="toolbox" role="toolbar" aria-label="Drawing Tools">
          <button class="tool-btn selected" data-tool="select" title="Select Tool">üî≤<small>Select</small></button>
          <button class="tool-btn" data-tool="rect" title="Rectangle Tool">‚ñ≠<small>Rectangle</small></button>
          <button class="tool-btn" data-tool="ellipse" title="Ellipse Tool">‚ö™<small>Ellipse</small></button>
          <button class="tool-btn" data-tool="line" title="Line Tool">‚ûñ<small>Line</small></button>
          <button class="tool-btn" data-tool="pen" title="Pen Tool">‚úèÔ∏è<small>Pen</small></button>
          <button class="tool-btn" data-tool="eraser" title="Eraser Tool">ü©π<small>Eraser</small></button>
          <button class="tool-btn" data-tool="polygon" title="Polygon Tool">üî∑<small>Polygon</small></button>
          <button class="tool-btn" data-tool="bezier" title="Bezier Tool">„Ä∞Ô∏è<small>Bezier</small></button>
          <button class="tool-btn" data-tool="text" title="Text Tool">üÖ∞Ô∏è<small>Text</small></button>
        </div>
        <div id="settings-bar" aria-label="Tool Settings">
          <div>
            <label for="fillColorPicker">Fill Color</label>
            <input type="color" id="fillColorPicker" value="#000000" aria-label="Fill Color Picker" />
          </div>
          <div>
            <label for="strokeColorPicker">Stroke Color</label>
            <input type="color" id="strokeColorPicker" value="#000000" aria-label="Stroke Color Picker" />
          </div>
          <div>
            <label for="strokeWidthInput">Stroke Width</label>
            <input type="number" id="strokeWidthInput" value="2" min="1" max="20" aria-label="Stroke Width Input" />
          </div>
          <div>
            <label for="polygonSidesInput">Polygon Sides</label>
            <input type="number" id="polygonSidesInput" value="5" min="3" max="12" aria-label="Polygon Sides Input" />
          </div>
        </div>
      </div>
      <div id="canvas-container">
        <canvas id="canvas" tabindex="0" aria-label="Drawing Canvas"></canvas>
      </div>
    </div>
    <div id="statusbar" role="status" aria-live="polite">
      <div id="currentTool">Tool: Select</div>
      <div id="coords">X: 0 Y: 0</div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const container = document.getElementById("canvas-container");
  const fillColorPicker = document.getElementById("fillColorPicker");
  const strokeColorPicker = document.getElementById("strokeColorPicker");
  const strokeWidthInput = document.getElementById("strokeWidthInput");
  const polygonSidesInput = document.getElementById("polygonSidesInput");
  const currentToolEl = document.getElementById("currentTool");
  const coordsEl = document.getElementById("coords");
  const toolbox = document.getElementById("toolbox");

  let w, h;
  let projectData = [];  // store all shapes here for saving/loading
  let history = [];
  let historyIndex = -1;

  let tool = "select";
  let isDrawing = false;
  let startX = 0, startY = 0;
  let currentShape = null;
  let selectedShape = null;
  let resizing = false;
  let activeHandle = null;

  let bezierPoints = [];

  function resize() {
    const rect = container.getBoundingClientRect();
    canvas.width = rect.width * 0.95;
    canvas.height = rect.height * 0.95;
    w = canvas.width;
    h = canvas.height;
    redraw();
  }
  window.addEventListener("resize", resize);

  function getCanvasCoords(e) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    let x = (e.clientX - rect.left) * scaleX;
    let y = (e.clientY - rect.top) * scaleY;
    x = Math.min(Math.max(0, x), canvas.width);
    y = Math.min(Math.max(0, y), canvas.height);
    return { x, y };
  }

  function saveState() {
    history = history.slice(0, historyIndex + 1);
    // deep copy projectData by JSON stringify/parse
    history.push(JSON.stringify(projectData));
    historyIndex++;
  }
  function undo() {
    if (historyIndex > 0) {
      historyIndex--;
      projectData = JSON.parse(history[historyIndex]);
      selectedShape = null;
      redraw();
    }
  }
  function redo() {
    if (historyIndex < history.length - 1) {
      historyIndex++;
      projectData = JSON.parse(history[historyIndex]);
      selectedShape = null;
      redraw();
    }
  }

  function setTool(name) {
    tool = name;
    [...toolbox.querySelectorAll(".tool-btn")].forEach(b => {
      const isActive = b.dataset.tool === name;
      b.classList.toggle("selected", isActive);
      b.setAttribute("aria-pressed", isActive ? "true" : "false");
    });
    selectedShape = null;
    bezierPoints = [];
    currentToolEl.textContent = "Tool: " + name.charAt(0).toUpperCase() + name.slice(1);
    redraw();
  }
  toolbox.addEventListener("click", e => {
    const btn = e.target.closest(".tool-btn");
    if (!btn) return;
    const newTool = btn.dataset.tool;
    if (newTool) setTool(newTool);
  });
  setTool("select");

  function redraw() {
    ctx.clearRect(0, 0, w, h);
    projectData.forEach(s => {
      ctx.fillStyle = s.fill || 'transparent';
      ctx.strokeStyle = s.color || '#000';
      ctx.lineWidth = s.width || 1;
      ctx.beginPath();

      if (s.type === "rect") {
        const x = Math.min(s.x1, s.x2), y = Math.min(s.y1, s.y2);
        const width = Math.abs(s.x2 - s.x1);
        const height = Math.abs(s.y2 - s.y1);
        if (s.fill) ctx.fillRect(x, y, width, height);
        ctx.strokeRect(x, y, width, height);
      } else if (s.type === "ellipse") {
        const rx = Math.abs((s.x2 - s.x1) / 2), ry = Math.abs((s.y2 - s.y1) / 2);
        const cx = Math.min(s.x1, s.x2) + rx;
        const cy = Math.min(s.y1, s.y2) + ry;
        ctx.ellipse(cx, cy, rx, ry, 0, 0, 2 * Math.PI);
        if (s.fill) ctx.fill();
        ctx.stroke();
      } else if (s.type === "line") {
        ctx.moveTo(s.x1, s.y1);
        ctx.lineTo(s.x2, s.y2);
        ctx.stroke();
      } else if (s.type === "pen") {
        if (s.points.length > 0) {
          ctx.moveTo(s.points[0].x, s.points[0].y);
          s.points.slice(1).forEach(p => ctx.lineTo(p.x, p.y));
          ctx.stroke();
          if (selectedShape === s) {
            ctx.fillStyle = "#ffd700";
            s.points.forEach(p => ctx.fillRect(p.x - 3, p.y - 3, 6, 6));
          }
        }
      } else if (s.type === "polygon") {
        drawPolygon(ctx, s.x1, s.y1, s.radius, s.sides);
        if (s.fill) ctx.fill();
        ctx.stroke();
      } else if (s.type === "bezier") {
        if (s.points.length === 4) {
          const [p0, p1, p2, p3] = s.points;
          ctx.moveTo(p0.x, p0.y);
          ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
          ctx.stroke();
          if (selectedShape === s) {
            ctx.fillStyle = "#ffd700";
            s.points.forEach(p => ctx.fillRect(p.x - 4, p.y - 4, 8, 8));
          }
        }
      } else if (s.type === "text") {
        ctx.fillStyle = s.color || "#000";
        ctx.font = `${s.fontSize || 20}px sans-serif`;
        ctx.fillText(s.text, s.x, s.y);
      }

      if (selectedShape === s) drawHandles(s);
    });
  }

  function drawPolygon(ctx, cx, cy, radius, sides) {
    if (sides < 3) return;
    const angle = (Math.PI * 2) / sides;
    ctx.beginPath();
    ctx.moveTo(cx + radius * Math.cos(0), cy + radius * Math.sin(0));
    for (let i = 1; i < sides; i++) {
      ctx.lineTo(cx + radius * Math.cos(i * angle), cy + radius * Math.sin(i * angle));
    }
    ctx.closePath();
  }

  function drawHandles(s) {
    removeHandles();
    let handles = [];

    if (s.type === "rect" || s.type === "ellipse") {
      const minX = Math.min(s.x1, s.x2);
      const maxX = Math.max(s.x1, s.x2);
      const minY = Math.min(s.y1, s.y2);
      const maxY = Math.max(s.y1, s.y2);
      handles = [
        { name: "tl", x: minX, y: minY },
        { name: "tr", x: maxX, y: minY },
        { name: "bl", x: minX, y: maxY },
        { name: "br", x: maxX, y: maxY }
      ];
    } else if (s.type === "polygon") {
      const angleStep = (Math.PI * 2) / s.sides;
      for (let i = 0; i < s.sides; i++) {
        handles.push({
          name: "v" + i,
          x: s.x1 + s.radius * Math.cos(i * angleStep),
          y: s.y1 + s.radius * Math.sin(i * angleStep)
        });
      }
    } else if (s.type === "bezier") {
      handles = s.points.map((p, i) => ({ name: "p" + i, x: p.x, y: p.y }));
    } else if (s.type === "pen") {
      handles = s.points.map((p, i) => ({ name: "p" + i, x: p.x, y: p.y }));
    } else if (s.type === "line") {
      handles = [
        { name: "start", x: s.x1, y: s.y1 },
        { name: "end", x: s.x2, y: s.y2 }
      ];
    } else if (s.type === "text") {
      handles = [{ name: "pos", x: s.x, y: s.y }];
    }

    handles.forEach(h => {
      const div = document.createElement("div");
      div.className = "handle";
      div.style.left = h.x + "px";
      div.style.top = h.y + "px";
      div.dataset.handle = h.name;
      div.dataset.shapeId = projectData.indexOf(selectedShape);
      div.setAttribute("aria-label", `Handle ${h.name}`);
      div.tabIndex = 0;
      div.addEventListener("mousedown", onHandleMouseDown);
      div.addEventListener("keydown", onHandleKeyDown);
      container.appendChild(div);
    });
  }

  function removeHandles() {
    const handles = container.querySelectorAll(".handle");
    handles.forEach(h => {
      h.removeEventListener("mousedown", onHandleMouseDown);
      h.removeEventListener("keydown", onHandleKeyDown);
      h.remove();
    });
  }

  // HANDLE DRAGGING
  let dragStart = null;
  function onHandleMouseDown(e) {
    e.stopPropagation();
    resizing = true;
    activeHandle = e.target.dataset.handle;
    const shapeId = parseInt(e.target.dataset.shapeId);
    selectedShape = projectData[shapeId];
    dragStart = getCanvasCoords(e);
    window.addEventListener("mousemove", onHandleMouseMove);
    window.addEventListener("mouseup", onHandleMouseUp);
  }
  function onHandleMouseMove(e) {
    if (!resizing || !selectedShape) return;
    const pos = getCanvasCoords(e);
    const dx = pos.x - dragStart.x;
    const dy = pos.y - dragStart.y;
    dragStart = pos;

    // Modify selectedShape based on handle and tool
    if (selectedShape.type === "rect" || selectedShape.type === "ellipse") {
      if (activeHandle === "tl") {
        selectedShape.x1 += dx;
        selectedShape.y1 += dy;
      } else if (activeHandle === "tr") {
        selectedShape.x2 += dx;
        selectedShape.y1 += dy;
      } else if (activeHandle === "bl") {
        selectedShape.x1 += dx;
        selectedShape.y2 += dy;
      } else if (activeHandle === "br") {
        selectedShape.x2 += dx;
        selectedShape.y2 += dy;
      }
    } else if (selectedShape.type === "line") {
      if (activeHandle === "start") {
        selectedShape.x1 += dx;
        selectedShape.y1 += dy;
      } else if (activeHandle === "end") {
        selectedShape.x2 += dx;
        selectedShape.y2 += dy;
      }
    } else if (selectedShape.type === "polygon") {
      // move center or vertices? For now move center
      selectedShape.x1 += dx;
      selectedShape.y1 += dy;
    } else if (selectedShape.type === "bezier" || selectedShape.type === "pen") {
      const index = parseInt(activeHandle.slice(1));
      if (!isNaN(index)) {
        selectedShape.points[index].x += dx;
        selectedShape.points[index].y += dy;
      }
    } else if (selectedShape.type === "text") {
      selectedShape.x += dx;
      selectedShape.y += dy;
    }

    redraw();
  }
  function onHandleMouseUp(e) {
    resizing = false;
    activeHandle = null;
    saveState();
    window.removeEventListener("mousemove", onHandleMouseMove);
    window.removeEventListener("mouseup", onHandleMouseUp);
  }

  function onHandleKeyDown(e) {
    if (!selectedShape) return;
    const step = 1;
    let dx = 0, dy = 0;
    if (e.key === "ArrowLeft") dx = -step;
    else if (e.key === "ArrowRight") dx = step;
    else if (e.key === "ArrowUp") dy = -step;
    else if (e.key === "ArrowDown") dy = step;
    if (dx || dy) {
      e.preventDefault();
      if (selectedShape.type === "rect" || selectedShape.type === "ellipse") {
        if (activeHandle === "tl") {
          selectedShape.x1 += dx;
          selectedShape.y1 += dy;
        } else if (activeHandle === "tr") {
          selectedShape.x2 += dx;
          selectedShape.y1 += dy;
        } else if (activeHandle === "bl") {
          selectedShape.x1 += dx;
          selectedShape.y2 += dy;
        } else if (activeHandle === "br") {
          selectedShape.x2 += dx;
          selectedShape.y2 += dy;
        }
      } else if (selectedShape.type === "line") {
        if (activeHandle === "start") {
          selectedShape.x1 += dx;
          selectedShape.y1 += dy;
        } else if (activeHandle === "end") {
          selectedShape.x2 += dx;
          selectedShape.y2 += dy;
        }
      } else if (selectedShape.type === "polygon") {
        selectedShape.x1 += dx;
        selectedShape.y1 += dy;
      } else if (selectedShape.type === "bezier" || selectedShape.type === "pen") {
        const index = parseInt(activeHandle.slice(1));
        if (!isNaN(index)) {
          selectedShape.points[index].x += dx;
          selectedShape.points[index].y += dy;
        }
      } else if (selectedShape.type === "text") {
        selectedShape.x += dx;
        selectedShape.y += dy;
      }
      redraw();
    }
  }

  // SELECTING SHAPES
  function hitTest(x, y) {
    for (let i = projectData.length - 1; i >= 0; i--) {
      const s = projectData[i];
      if (s.type === "rect") {
        let minX = Math.min(s.x1, s.x2), maxX = Math.max(s.x1, s.x2);
        let minY = Math.min(s.y1, s.y2), maxY = Math.max(s.y1, s.y2);
        if (x >= minX && x <= maxX && y >= minY && y <= maxY) return s;
      } else if (s.type === "ellipse") {
        let rx = Math.abs((s.x2 - s.x1) / 2);
        let ry = Math.abs((s.y2 - s.y1) / 2);
        let cx = Math.min(s.x1, s.x2) + rx;
        let cy = Math.min(s.y1, s.y2) + ry;
        let dx = x - cx;
        let dy = y - cy;
        if ((dx * dx) / (rx * rx) + (dy * dy) / (ry * ry) <= 1) return s;
      } else if (s.type === "line") {
        // simple hit test for line (within 5 px)
        const dist = distToSegment({ x, y }, { x: s.x1, y: s.y1 }, { x: s.x2, y: s.y2 });
        if (dist <= 5) return s;
      } else if (s.type === "polygon") {
        if (pointInPolygon({ x, y }, polygonPoints(s))) return s;
      } else if (s.type === "bezier") {
        // Approximate by bounding box
        const xs = s.points.map(p => p.x);
        const ys = s.points.map(p => p.y);
        const minX = Math.min(...xs), maxX = Math.max(...xs);
        const minY = Math.min(...ys), maxY = Math.max(...ys);
        if (x >= minX && x <= maxX && y >= minY && y <= maxY) return s;
      } else if (s.type === "pen") {
        // check points proximity
        for (const p of s.points) {
          if (Math.abs(p.x - x) < 5 && Math.abs(p.y - y) < 5) return s;
        }
      } else if (s.type === "text") {
        ctx.font = `${s.fontSize || 20}px sans-serif`;
        const width = ctx.measureText(s.text).width;
        const height = s.fontSize || 20;
        if (x >= s.x && x <= s.x + width && y >= s.y - height && y <= s.y) return s;
      }
    }
    return null;
  }

  function distToSegment(p, v, w) {
    const l2 = (w.x - v.x) ** 2 + (w.y - v.y) ** 2;
    if (l2 === 0) return Math.hypot(p.x - v.x, p.y - v.y);
    let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
    t = Math.max(0, Math.min(1, t));
    return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
  }

  function pointInPolygon(point, vs) {
    let x = point.x, y = point.y;
    let inside = false;
    for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
      const xi = vs[i].x, yi = vs[i].y;
      const xj = vs[j].x, yj = vs[j].y;
      const intersect = ((yi > y) !== (yj > y)) &&
        (x < ((xj - xi) * (y - yi)) / (yj - yi) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }
  function polygonPoints(poly) {
    let points = [];
    const angleStep = (Math.PI * 2) / poly.sides;
    for (let i = 0; i < poly.sides; i++) {
      points.push({
        x: poly.x1 + poly.radius * Math.cos(i * angleStep),
        y: poly.y1 + poly.radius * Math.sin(i * angleStep)
      });
    }
    return points;
  }

  // DRAWING LOGIC
  canvas.addEventListener("mousedown", e => {
    const pos = getCanvasCoords(e);
    startX = pos.x;
    startY = pos.y;

    if (tool === "select") {
      selectedShape = hitTest(pos.x, pos.y);
      redraw();
      return;
    }

    isDrawing = true;
    currentShape = null;

    if (tool === "rect" || tool === "ellipse" || tool === "line") {
      currentShape = {
        type: tool,
        x1: startX,
        y1: startY,
        x2: startX,
        y2: startY,
        color: strokeColorPicker.value,
        width: parseInt(strokeWidthInput.value),
        fill: fillColorPicker.value === "#000000" ? null : fillColorPicker.value
      };
    } else if (tool === "polygon") {
      currentShape = {
        type: "polygon",
        x1: startX,
        y1: startY,
        radius: 0,
        sides: parseInt(polygonSidesInput.value),
        color: strokeColorPicker.value,
        width: parseInt(strokeWidthInput.value),
        fill: fillColorPicker.value === "#000000" ? null : fillColorPicker.value
      };
    } else if (tool === "pen") {
      currentShape = {
        type: "pen",
        points: [{ x: startX, y: startY }],
        color: strokeColorPicker.value,
        width: parseInt(strokeWidthInput.value),
        fill: null
      };
    } else if (tool === "bezier") {
      bezierPoints = [{ x: startX, y: startY }];
      currentShape = null;
    } else if (tool === "eraser") {
      // erase any shape hit at this pos
      const target = hitTest(startX, startY);
      if (target) {
        const idx = projectData.indexOf(target);
        if (idx !== -1) {
          projectData.splice(idx, 1);
          selectedShape = null;
          saveState();
          redraw();
        }
      }
      isDrawing = false;
    } else if (tool === "text") {
      const text = prompt("Enter text:");
      if (text) {
        const newText = {
          type: "text",
          x: startX,
          y: startY,
          text,
          color: strokeColorPicker.value,
          fontSize: 20
        };
        projectData.push(newText);
        selectedShape = newText;
        saveState();
        redraw();
      }
      isDrawing = false;
    }
  });

  canvas.addEventListener("mousemove", e => {
    const pos = getCanvasCoords(e);
    coordsEl.textContent = `X: ${pos.x.toFixed(0)} Y: ${pos.y.toFixed(0)}`;

    if (!isDrawing || !currentShape) return;

    if (tool === "rect" || tool === "ellipse" || tool === "line") {
      currentShape.x2 = pos.x;
      currentShape.y2 = pos.y;
    } else if (tool === "polygon") {
      currentShape.radius = Math.hypot(pos.x - startX, pos.y - startY);
    } else if (tool === "pen") {
      currentShape.points.push({ x: pos.x, y: pos.y });
    } else if (tool === "bezier") {
      if (bezierPoints.length < 4) {
        bezierPoints.push({ x: pos.x, y: pos.y });
      } else {
        bezierPoints[bezierPoints.length - 1] = { x: pos.x, y: pos.y };
      }
    }

    redraw();

    if (isDrawing && currentShape) {
      ctx.strokeStyle = currentShape.color;
      ctx.lineWidth = currentShape.width;
      ctx.fillStyle = currentShape.fill || 'transparent';
      ctx.beginPath();

      if (currentShape.type === "rect") {
        const x = Math.min(currentShape.x1, currentShape.x2);
        const y = Math.min(currentShape.y1, currentShape.y2);
        const width = Math.abs(currentShape.x2 - currentShape.x1);
        const height = Math.abs(currentShape.y2 - currentShape.y1);
        if (currentShape.fill) ctx.fillRect(x, y, width, height);
        ctx.strokeRect(x, y, width, height);
      } else if (currentShape.type === "ellipse") {
        const rx = Math.abs((currentShape.x2 - currentShape.x1) / 2);
        const ry = Math.abs((currentShape.y2 - currentShape.y1) / 2);
        const cx = Math.min(currentShape.x1, currentShape.x2) + rx;
        const cy = Math.min(currentShape.y1, currentShape.y2) + ry;
        ctx.ellipse(cx, cy, rx, ry, 0, 0, 2 * Math.PI);
        if (currentShape.fill) ctx.fill();
        ctx.stroke();
      } else if (currentShape.type === "line") {
        ctx.moveTo(currentShape.x1, currentShape.y1);
        ctx.lineTo(currentShape.x2, currentShape.y2);
        ctx.stroke();
      } else if (currentShape.type === "polygon") {
        drawPolygon(ctx, currentShape.x1, currentShape.y1, currentShape.radius, currentShape.sides);
        if (currentShape.fill) ctx.fill();
        ctx.stroke();
      } else if (currentShape.type === "pen") {
        if (currentShape.points.length > 0) {
          ctx.moveTo(currentShape.points[0].x, currentShape.points[0].y);
          currentShape.points.slice(1).forEach(p => ctx.lineTo(p.x, p.y));
          ctx.stroke();
        }
      }
    } else if (tool === "bezier" && bezierPoints.length > 1) {
      ctx.beginPath();
      ctx.moveTo(bezierPoints[0].x, bezierPoints[0].y);
      if (bezierPoints.length === 4) {
        ctx.bezierCurveTo(bezierPoints[1].x, bezierPoints[1].y,
                          bezierPoints[2].x, bezierPoints[2].y,
                          bezierPoints[3].x, bezierPoints[3].y);
      } else {
        bezierPoints.slice(1).forEach(p => ctx.lineTo(p.x, p.y));
      }
      ctx.strokeStyle = strokeColorPicker.value;
      ctx.lineWidth = strokeWidthInput.value;
      ctx.stroke();
    }
  });

  canvas.addEventListener("mouseup", e => {
    if (!isDrawing) return;
    isDrawing = false;

    if (tool === "rect" || tool === "ellipse" || tool === "line" || tool === "polygon" || tool === "pen") {
      if (currentShape) {
        projectData.push(currentShape);
        selectedShape = currentShape;
        saveState();
      }
    } else if (tool === "bezier") {
      if (bezierPoints.length === 4) {
        const bezierShape = {
          type: "bezier",
          points: [...bezierPoints],
          color: strokeColorPicker.value,
          width: parseInt(strokeWidthInput.value)
        };
        projectData.push(bezierShape);
        selectedShape = bezierShape;
        saveState();
      }
      bezierPoints = [];
    }
    currentShape = null;
    redraw();
  });

  // UNDO/REDO BUTTONS
  document.getElementById("undoBtn").onclick = undo;
  document.getElementById("redoBtn").onclick = redo;

  // EXPORT PNG
  document.getElementById("exportPNGBtn").onclick = () => {
    canvas.toBlob(blob => {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "drawing.png";
      a.click();
      URL.revokeObjectURL(url);
    }, "image/png");
  };

  // SAVE .oi (JSON) BUTTON
  document.getElementById("saveOI").onclick = () => {
    const data = JSON.stringify(projectData, null, 2);
    const blob = new Blob([data], { type: "application/json" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "drawing.oi";
    a.click();
  };

  // LOAD .oi BUTTON & FILE INPUT
  const fileInput = document.getElementById("fileInput");
  document.getElementById("loadOI").onclick = () => {
    fileInput.click();
  };
  fileInput.addEventListener("change", e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      try {
        projectData = JSON.parse(reader.result);
        selectedShape = null;
        saveState();
        redraw();
      } catch (err) {
        alert("Invalid .oi file");
      }
    };
    reader.readAsText(file);
    e.target.value = "";
  });

  // INITIALIZE
  resize();
  saveState();

  // Keyboard shortcuts for undo/redo
  window.addEventListener("keydown", e => {
    if (e.ctrlKey && !e.shiftKey && e.key.toLowerCase() === "z") {
      e.preventDefault();
      undo();
    } else if ((e.ctrlKey && e.key.toLowerCase() === "y") || (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === "z")) {
      e.preventDefault();
      redo();
    }
  });
})();
</script>
</body>
</html>
