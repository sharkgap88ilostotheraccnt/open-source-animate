<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Open Illustrator</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #1e1e1e;
      font-family: sans-serif;
      color: white;
    }
    #toolbar {
      position: absolute;
      top: 0;
      left: 0;
      width: 50px;
      background: #333;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 10px;
    }
    #toolbar button {
      background: none;
      border: none;
      color: white;
      font-size: 18px;
      margin: 5px;
      cursor: pointer;
    }
    #toolbar button.active {
      background: #555;
    }
    canvas {
      position: absolute;
      left: 50px;
      top: 0;
      width: calc(100% - 50px);
      height: 100%;
      cursor: crosshair;
    }
  </style>
</head>
<body>

<div id="toolbar">
  <button data-tool="select">‚òê</button>
  <button data-tool="rect">‚ñ≠</button>
  <button data-tool="ellipse">‚¨≠</button>
  <button data-tool="line">Ôºè</button>
  <button data-tool="eraser">‚å´</button>
  <button data-tool="triangle">‚ñ≤</button>
  <button data-tool="star">‚òÖ</button>
  <button data-tool="text">T</button>
  <button data-tool="bezier">‚úí</button>
  <button data-tool="fill">ü™£</button>
  <button data-tool="zoom">üîç</button>
  <button data-tool="pan">‚úã</button>
</div>

<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
let tool = "select";
let shapes = [];
let isDrawing = false;
let startX, startY;
let zoom = 1;
let offsetX = 0, offsetY = 0;
let bezierPoints = [];

function resize() {
  canvas.width = window.innerWidth - 50;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

document.querySelectorAll("#toolbar button").forEach(btn => {
  btn.onclick = () => {
    tool = btn.dataset.tool;
    document.querySelectorAll("#toolbar button").forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
    bezierPoints = [];
  };
});

function drawShape(shape) {
  ctx.save();
  ctx.translate(offsetX, offsetY);
  ctx.scale(zoom, zoom);
  ctx.beginPath();
  switch (shape.type) {
    case "rect":
      ctx.rect(shape.x, shape.y, shape.w, shape.h);
      break;
    case "ellipse":
      ctx.ellipse(shape.x + shape.w / 2, shape.y + shape.h / 2, Math.abs(shape.w / 2), Math.abs(shape.h / 2), 0, 0, 2 * Math.PI);
      break;
    case "line":
      ctx.moveTo(shape.x, shape.y);
      ctx.lineTo(shape.x2, shape.y2);
      break;
    case "triangle":
      ctx.moveTo(shape.x + shape.w / 2, shape.y);
      ctx.lineTo(shape.x, shape.y + shape.h);
      ctx.lineTo(shape.x + shape.w, shape.y + shape.h);
      ctx.closePath();
      break;
    case "star":
      let cx = shape.x + shape.w / 2;
      let cy = shape.y + shape.h / 2;
      let spikes = 5;
      let outer = Math.min(shape.w, shape.h) / 2;
      let inner = outer / 2;
      let rot = Math.PI / 2 * 3;
      let step = Math.PI / spikes;
      ctx.moveTo(cx, cy - outer);
      for (let i = 0; i < spikes; i++) {
        ctx.lineTo(cx + Math.cos(rot) * outer, cy + Math.sin(rot) * outer);
        rot += step;
        ctx.lineTo(cx + Math.cos(rot) * inner, cy + Math.sin(rot) * inner);
        rot += step;
      }
      ctx.lineTo(cx, cy - outer);
      ctx.closePath();
      break;
    case "bezier":
      ctx.moveTo(shape.p0.x, shape.p0.y);
      ctx.bezierCurveTo(shape.p1.x, shape.p1.y, shape.p2.x, shape.p2.y, shape.p3.x, shape.p3.y);
      break;
    case "text":
      ctx.font = "16px sans-serif";
      ctx.fillText(shape.text, shape.x, shape.y);
      break;
  }
  ctx.fillStyle = shape.fill || "#fff";
  ctx.fill();
  ctx.strokeStyle = shape.stroke || "#000";
  ctx.stroke();
  ctx.restore();
}

function redraw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (const shape of shapes) {
    drawShape(shape);
  }
}

canvas.onmousedown = (e) => {
  const mx = (e.offsetX - offsetX) / zoom;
  const my = (e.offsetY - offsetY) / zoom;
  startX = mx;
  startY = my;
  isDrawing = true;

  if (tool === "bezier") {
    bezierPoints.push({ x: mx, y: my });
    if (bezierPoints.length === 4) {
      shapes.push({ type: "bezier", p0: bezierPoints[0], p1: bezierPoints[1], p2: bezierPoints[2], p3: bezierPoints[3] });
      bezierPoints = [];
      redraw();
    }
    return;
  }

  if (tool === "fill") {
    // Simple placeholder for fill: flood-fill not implemented
    shapes.push({ type: "rect", x: mx - 5, y: my - 5, w: 10, h: 10, fill: "#0cf", stroke: "#0cf" });
    redraw();
    return;
  }

  if (tool === "text") {
    const text = prompt("Enter text:");
    if (text) {
      shapes.push({ type: "text", x: mx, y: my, text: text });
      redraw();
    }
    return;
  }
};

canvas.onmousemove = (e) => {
  if (!isDrawing) return;
  const mx = (e.offsetX - offsetX) / zoom;
  const my = (e.offsetY - offsetY) / zoom;

  if (tool === "pan") {
    offsetX += e.movementX;
    offsetY += e.movementY;
    redraw();
    return;
  }

  redraw();

  if (["rect", "ellipse", "triangle", "star", "line"].includes(tool)) {
    const tempShape = {
      type: tool,
      x: startX,
      y: startY,
      w: mx - startX,
      h: my - startY,
      x2: mx,
      y2: my
    };
    drawShape(tempShape);
  }
};

canvas.onmouseup = (e) => {
  if (!isDrawing) return;
  isDrawing = false;
  const mx = (e.offsetX - offsetX) / zoom;
  const my = (e.offsetY - offsetY) / zoom;

  if (["rect", "ellipse", "triangle", "star", "line"].includes(tool)) {
    shapes.push({
      type: tool,
      x: startX,
      y: startY,
      w: mx - startX,
      h: my - startY,
      x2: mx,
      y2: my
    });
    redraw();
  }
};

canvas.addEventListener("wheel", (e) => {
  if (tool === "zoom") {
    const delta = e.deltaY > 0 ? 0.9 : 1.1;
    zoom *= delta;
    redraw();
  }
});
</script>
</body>
</html>
